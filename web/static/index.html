<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tractor Map</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 160px;
        }
        #controlPanel {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 200px;
        }
        .control-group {
            margin: 10px 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
        }
        .control-value {
            display: inline-block;
            text-align: right;
            margin-left: 10px;
        }
        input[type="range"] {
            width: 100%;
        }
        .center-button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin: 10px auto 0;
            font-family: monospace;
            display: block;
            width: 120px;
        }
        .center-button:hover {
            background: #555;
        }
        #cameraPanel {
            position: absolute;
            top: 150px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 150px;
        }
        .camera-button {
            background: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px 0;
            font-family: monospace;
            display: block;
            width: 100%;
        }
        .camera-button.active {
            background: #666;
        }
        .camera-button:hover {
            background: #555;
        }
        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 250px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }
        #updateCounter {
            position: absolute;
            top: 10px;
            left: 350px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }
        /* Add configuration panel styles */
        .config-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 200px;
        }
        .config-form {
            margin-bottom: 10px;
        }
        .config-group {
            margin-bottom: 10px;
        }
        .config-item {
            margin-bottom: 5px;
        }
        .config-item label {
            display: block;
            margin-bottom: 5px;
        }
        .config-item input[type="number"] {
            width: 100%;
        }
        .config-button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
            font-family: monospace;
            display: block;
            width: 100%;
        }
        .config-button:hover {
            background: #555;
        }
    </style>
    <!-- Add configuration panel -->
    <div id="configPanel" class="config-panel">
        <h2>Tractor & Implement Configuration</h2>
        <div class="config-form">
            <div class="config-group">
                <h3>Tractor Settings</h3>
                <div class="config-item">
                    <label for="wheelbase">Wheelbase (meters):</label>
                    <input type="number" id="wheelbase" value="2.86" step="0.1" min="0.1">
                </div>
                <div class="config-item">
                    <label for="hitchOffset">Hitch Offset (meters):</label>
                    <input type="number" id="hitchOffset" value="1.0" step="0.1" min="0.1">
                </div>
            </div>
            <div class="config-group">
                <h3>Implement Settings</h3>
                <div class="config-item">
                    <label for="implementLength">Length (meters):</label>
                    <input type="number" id="implementLength" value="5.0" step="0.1" min="0.1">
                </div>
                <div class="config-item">
                    <label for="implementWidth">Width (meters):</label>
                    <input type="number" id="implementWidth" value="10.0" step="0.1" min="0.1">
                </div>
            </div>
            <button id="startSimulation" class="config-button" disabled>Start Simulation</button>
        </div>
    </div>
    <div id="guidanceTuningPanel" style="position: absolute; bottom: 20px; right: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 5px; font-family: monospace; z-index: 100; min-width: 200px;">
        <h3 style="margin-top: 0;">Guidance Tuning</h3>
        <div class="control-group">
            <label for="lookAheadControl">Look-ahead Distance (m)</label>
            <input type="range" id="lookAheadControl" min="0.1" max="10.0" step="0.1" value="1.0">
            <span id="lookAheadValue" class="control-value">1.0</span>
        </div>
        <div class="control-group">
            <label for="planningDistControl">Planning Distance (m)</label>
            <input type="range" id="planningDistControl" min="1.0" max="50.0" step="1.0" value="10.0">
            <span id="planningDistValue" class="control-value">10.0</span>
        </div>
        <div class="control-group">
            <label for="deadzoneControl">Deadzone (degrees)</label>
            <input type="range" id="deadzoneControl" min="0.0" max="5.0" step="0.1" value="1.0">
            <span id="deadzoneValue" class="control-value">1.0</span>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three/examples/js/loaders/TextureLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="tractormodel.js"></script>
    <script src="implementmodel.js"></script>
</head>
<body>
    <div id="coordinates">
        Lat: 0.000°<br>
        Lon: 0.000°<br>
        Heading: 0.0°<br>
        Speed: 0.0 km/h
    </div>
    <div id="fpsCounter">
        FPS: 0
    </div>
    <div id="updateCounter">
        Updates/s: 0
    </div>
    <div id="controlPanel">
        <h3 style="margin-top: 0;">Tractor Controls</h3>
        <div class="control-group">
            <label for="speedControl">Speed (km/h)</label>
            <input type="range" id="speedControl" min="0" max="30" step="0.1" value="0">
            <span id="speedValue" class="control-value">0.0</span>
        </div>
        <div class="control-group">
            <label for="steeringControl">
                Steering
                <label style="display: inline; margin-left: 10px;">
                    <input type="checkbox" id="autoSteeringCheckbox"> Auto
                </label>
            </label>
            <div style="display: flex; justify-content: space-between; font-size: 0.8em; margin-bottom: 2px;">
                <span>Left 30°</span>
                <span>Right 30°</span>
            </div>
            <input type="range" id="steeringControl" min="-30" max="30" step="0.1" value="0">
            <span id="steeringValue" style="width: 90px;" class="control-value">Center</span>
        </div>
        <button id="centerSteering" class="center-button">Center Steering</button>
        <button id="resetSimulation" class="center-button" style="margin-top: 10px; background-color: #d44;">Reset Simulation</button>
    </div>
    <div id="cameraPanel">
        <h3 style="margin-top: 0;">Camera View</h3>
        <button id="thirdPersonView" class="camera-button active">Third Person</button>
        <button id="followView" class="camera-button">Follow</button>
        <button id="firstPersonView" class="camera-button">First Person</button>
    </div>
    <button id="resetCamera" style="position: absolute; bottom: 20px; right: 20px; padding: 10px; z-index: 100;">
        Reset Camera
    </button>
    <script>
        // Initialize Three.js scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create guidance arrow
        const guidanceArrowLength = 20;
        const guidanceArrowColor = 0x00ff00; // green
        const guidanceArrow = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0), // direction - will be updated
            new THREE.Vector3(0, 1, 0), // origin - will be updated
            guidanceArrowLength,
            guidanceArrowColor,
            5, // headLength
            3  // headWidth
        );
        guidanceArrow.renderOrder = 2; // Ensure arrow renders above other elements
        scene.add(guidanceArrow);

        // Initialize OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movements
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 5000;
        controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below ground

        // Add reset camera function
        function resetCamera() {
            controls.reset();
            camera.position.set(0, 200, 200);
            if (tractor) {
                controls.target.copy(tractor.position);
            }
        }

        // Add event listener for reset button
        document.getElementById('resetCamera').addEventListener('click', resetCamera);

        // Hide all UI elements initially except config panel
        document.getElementById('coordinates').style.display = 'none';
        document.getElementById('fpsCounter').style.display = 'none';
        document.getElementById('updateCounter').style.display = 'none';
        document.getElementById('controlPanel').style.display = 'none';
        document.getElementById('cameraPanel').style.display = 'none';
        document.getElementById('resetCamera').style.display = 'none';

        // Configuration handling
        let ws;
        let configSent = false;
        let tractor = null;
        let implement = null;
        let animationStarted = false;
        
        // Add these variables to store guidance information
        let targetPoint = { X: 0, Y: 0 };
        let targetSteeringAngle = 0;
        
        // Initialize WebSocket connection
        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.host}/ws`);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                document.getElementById('startSimulation').disabled = false;
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'position' && tractor) {
                    // Count position updates
                    positionUpdates++;
                    
                    // Calculate updates per second every second
                    const time = performance.now();
                    if (time >= updatePrevTime + 1000) {
                        const updatesPerSec = Math.round((positionUpdates * 1000) / (time - updatePrevTime));
                        updateDisplay.textContent = `Updates/s: ${updatesPerSec}`;
                        positionUpdates = 0;
                        updatePrevTime = time;
                    }

                    tractorPosition = {
                        lat: data.tractorPos.Lat,
                        lon: data.tractorPos.Lon,
                        heading: data.tractorPos.Heading,
                        speed: data.tractorPos.Speed,  
                        time: new Date(data.tractorPos.Time),
                        worldX: data.tractorWorldPos.X,
                        worldY: data.tractorWorldPos.Y,
                        worldHeading: data.tractorWorldPos.Heading
                    };

                    implementPosition = {
                        lat: data.implementPos.Lat,
                        lon: data.implementPos.Lon,
                        heading: data.implementPos.Heading,
                        speed: data.implementPos.Speed,  
                        time: new Date(data.implementPos.Time),
                        worldX: data.implementWorldPos.X,
                        worldY: data.implementWorldPos.Y,
                        worldHeading: data.implementWorldPos.Heading
                    };

                    articulationAngle = implementPosition.worldHeading - tractorPosition.worldHeading;
                    
                    // Update tractor position and rotation
                    tractor.position.x = tractorPosition.worldX;
                    tractor.position.z = -tractorPosition.worldY;
                    tractor.rotation.y = tractorPosition.worldHeading + Math.PI/2;

                    // Update implement angle
                    tractor.setImplementAngle(articulationAngle);

                    // Update guidance arrow origin to match tractor position
                    guidanceArrow.position.set(tractorPosition.worldX, 1, -tractorPosition.worldY);

                    // Update path points
                    tractorPathPoints.push(new THREE.Vector3(tractorPosition.worldX, 0.1, -tractorPosition.worldY));
                    tractorPathGeometry.setFromPoints(tractorPathPoints);

                    // Update implement path points
                    implementPathPoints.push(new THREE.Vector3(implementPosition.worldX, 0.1, -implementPosition.worldY));
                    implementPathGeometry.setFromPoints(implementPathPoints);
                }
                if (data.type === 'field') {
                    // Update field boundary
                    fieldBoundaryPoints.length = 0;
                    data.boundary.forEach(point => {
                        fieldBoundaryPoints.push(new THREE.Vector3(point.X, 0.1, -point.Y));
                    });
                    // Close the boundary
                    if (data.boundary.length > 0) {
                        fieldBoundaryPoints.push(new THREE.Vector3(
                            data.boundary[0].X, 0.1, -data.boundary[0].Y
                        ));
                    }
                    fieldBoundaryGeometry.setFromPoints(fieldBoundaryPoints);
                    
                    // Request path calculation
                    requestPathCalculation();
                }
                else if (data.type === 'path') {
                    // Update AB line path
                    abPathPoints.length = 0;
                    data.points.forEach(point => {
                        abPathPoints.push(new THREE.Vector3(point.X, 0.1, -point.Y));
                    });
                    abPathGeometry.setFromPoints(abPathPoints);
                } else if (data.type === 'guidance') {
                    // Update guidance arrow direction
                    if (tractor) {
                        targetPoint = data.targetPoint;
                        targetSteeringAngle = data.steeringAngle;
                        const targetPoint3D = new THREE.Vector3(data.targetPoint.X, 1, -data.targetPoint.Y);
                        const tractorPos = new THREE.Vector3(tractorPosition.worldX, 1, -tractorPosition.worldY);
                        const direction = targetPoint3D.clone().sub(tractorPos).normalize();
                        guidanceArrow.setDirection(direction);
                        guidanceArrow.setLength(guidanceArrowLength);
                        updateCoordinates(); // Update display when guidance info changes
                        updateAutoSteering(); // Update auto-steering if enabled
                    }
                }

                // Add reset simulation handler
                document.getElementById('resetSimulation').addEventListener('click', function() {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Reset speed and steering controls
                        speedControl.value = 0;
                        speedValue.textContent = '0.0';
                        steeringControl.value = 0;
                        steeringValue.textContent = 'Center';
                        steeringControl.disabled = false;
                        autoSteeringCheckbox.checked = false;
                        tractor.setImplementAngle(0);
                        tractor.setSteeringAngle(0);

                        // Clear path arrays
                        tractorPathPoints.length = 0;
                        implementPathPoints.length = 0;
                        abPathPoints.length = 0;
                        
                        // Reset path geometries
                        tractorPathGeometry.setFromPoints(tractorPathPoints);
                        implementPathGeometry.setFromPoints(implementPathPoints);
                        abPathGeometry.setFromPoints(abPathPoints);
                        
                        // Send reset command to server
                        ws.send(JSON.stringify({type: 'reset'}));
                    }
                });
            };
            
            ws.onclose = function() {
                console.log('WebSocket disconnected, attempting to reconnect...');
                document.getElementById('startSimulation').disabled = true;
                setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                document.getElementById('startSimulation').disabled = true;
            };
        }

        // Connect to WebSocket when page loads
        connectWebSocket();

        // Add function to send tractor controls
        function sendTractorControls() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const controls = {
                    type: 'control',
                    speed: parseFloat(speedControl.value),
                    steeringAngle: parseFloat(steeringControl.value)
                };
                ws.send(JSON.stringify(controls));
            }
        }

        function createModels(config) {
            // Create tractor with configured dimensions
            tractor = tractorModel(config.tractor.wheelbase, config.tractor.hitchOffset);
            
            // Create implement with configured dimensions
            implement = implementModel(config.implement.width, config.implement.length);
            
            // Add implement to tractor
            addImplement(tractor, implement);
            
            // Add to scene
            scene.add(tractor);
            
            // Position camera for better view
            camera.position.set(0, 200, 200);
            camera.lookAt(tractor.position.x, tractor.position.y+10, tractor.position.z);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);
        }
        
        function sendConfiguration() {
            const config = {
                type: 'config',
                tractor: {
                    wheelbase: parseFloat(document.getElementById('wheelbase').value),
                    hitchOffset: parseFloat(document.getElementById('hitchOffset').value)
                },
                implement: {
                    length: parseFloat(document.getElementById('implementLength').value),
                    width: parseFloat(document.getElementById('implementWidth').value)
                }
            };

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(config));
                configSent = true;
                
                // Create 3D models with configured dimensions
                createModels(config);
                
                // Show all UI elements
                document.getElementById('coordinates').style.display = 'block';
                document.getElementById('fpsCounter').style.display = 'block';
                document.getElementById('updateCounter').style.display = 'block';
                document.getElementById('controlPanel').style.display = 'block';
                document.getElementById('cameraPanel').style.display = 'block';
                document.getElementById('resetCamera').style.display = 'block';
                
                // Show guidance tuning panel
                document.getElementById('guidanceTuningPanel').style.display = 'block';
                
                // Send initial guidance parameters
                sendGuidanceParameters();
                
                // Hide config panel
                document.getElementById('configPanel').style.display = 'none';
                
                // Start the animation loop if not already started
                if (!animationStarted) {
                    animationStarted = true;
                    animate();
                }
            }
            
            // Request field boundary after configuration
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({type: 'getField'}));
            }
        }

        document.getElementById('startSimulation').addEventListener('click', sendConfiguration);

        // Replace the ground plane creation with this tile-based system
        // 36°48'04.7"S 142°18'51.3"E
        const METERS_PER_TILE = 4.78 * 1000; // 4.78km at zoom level 13
        const TILE_SIZE = METERS_PER_TILE; // Scene units are now in meters
        const initialLat = -36.8013;
        const initialLon = 142.3142;
        const zoom = 13; // Adjust zoom level as needed

        // Update mock data to include heading and speed
        let tractorPosition = {
            lat: -36.8013,
            lon: 142.3142,
            worldX: 0,
            worldY: 0,
            worldHeading: 0,
            heading: 45.0,
            speed: 8.5,
            time: new Date()
        };

        function lon2tile(lon, zoom) {
            return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
        }

        function lat2tile(lat, zoom) {
            return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
        }

        function loadMapTile(x, y, zoom) {
            const loader = new THREE.TextureLoader();
            // Using OpenStreetMap tiles (you can replace with Mapbox or other providers)
            const url = `https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
            
            return new Promise((resolve) => {
                loader.load(url, (texture) => {
                    const geometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        side: THREE.DoubleSide 
                    });
                    const tile = new THREE.Mesh(geometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    resolve(tile);
                });
            });
        }

        // Load initial tiles
        async function loadInitialTiles() {
            const centerTileX = lon2tile(initialLon, zoom);
            const centerTileY = lat2tile(initialLat, zoom);
            
            // Load 3x3 grid of tiles
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const tile = await loadMapTile(centerTileX + i, centerTileY + j, zoom);
                    tile.position.set(i * TILE_SIZE, 0, j * TILE_SIZE);
                    scene.add(tile);
                }
            }
        }

        // Remove the old ground plane code and call loadInitialTiles
        loadInitialTiles();

        // add an arrow to the scene pointing north
        const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 100, 0x00ff00);
        scene.add(arrowY);

        const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 100, 0xff0000);
        scene.add(arrowX);

        const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 100, 0x0000ff);
        scene.add(arrowZ);

        // Add after scene initialization and before tractor model creation
        // Create line for tractor path
        const tractorPathPoints = [];
        const tractorPathGeometry = new THREE.BufferGeometry();
        const tractorPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, // green
            linewidth: 2,  // Note: linewidth only works in WebGLRenderer2
            side: THREE.DoubleSide
        });
        const tractorPath = new THREE.Line(tractorPathGeometry, tractorPathMaterial);
        tractorPath.renderOrder = 1; // Ensure path renders above ground
        tractorPath.material.depthTest = false; // Prevent z-fighting with ground
        tractorPath.frustumCulled = false;
        scene.add(tractorPath);

        // implement path
        const implementPathPoints = [];
        const implementPathGeometry = new THREE.BufferGeometry();
        const implementPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, // red
            linewidth: 2,  // Note: linewidth only works in WebGLRenderer2
            side: THREE.DoubleSide
        });


        const implementPath = new THREE.Line(implementPathGeometry, implementPathMaterial);
        implementPath.renderOrder = 1; // Ensure path renders above ground
        implementPath.material.depthTest = false; // Prevent z-fighting with ground
        implementPath.frustumCulled = false;
        scene.add(implementPath);

        // Add after the implement path creation and before the WebSocket message handler
        // Create field boundary line
        const fieldBoundaryPoints = [];
        const fieldBoundaryGeometry = new THREE.BufferGeometry();
        const fieldBoundaryMaterial = new THREE.LineBasicMaterial({ 
            color: 0x0000ff, // blue
            linewidth: 2,
            side: THREE.DoubleSide
        });
        const fieldBoundary = new THREE.Line(fieldBoundaryGeometry, fieldBoundaryMaterial);
        fieldBoundary.renderOrder = 1;
        fieldBoundary.material.depthTest = false;
        fieldBoundary.frustumCulled = false;
        scene.add(fieldBoundary);

        // Create AB line path
        const abPathPoints = [];
        const abPathGeometry = new THREE.BufferGeometry();
        const abPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0x800080, // purple
            linewidth: 2,
            side: THREE.DoubleSide
        });
        const abPath = new THREE.Line(abPathGeometry, abPathMaterial);
        abPath.renderOrder = 1;
        abPath.material.depthTest = false;
        abPath.frustumCulled = false;
        scene.add(abPath);

        // Add after scene initialization
        let currentCameraView = 'thirdPerson'; // Global variable for camera view
        
        // Camera position constants
        const THIRD_PERSON_OFFSET = new THREE.Vector3(0, 10, -20);
        const FIRST_PERSON_OFFSET = new THREE.Vector3(0, 2, 0);
        
        // Update camera position based on view mode
        function updateCameraPosition() {
            if (!tractor) return; // Don't update camera if tractor doesn't exist yet
            
            if (currentCameraView === 'thirdPerson') {
                // Position camera behind tractor
                const offset = THIRD_PERSON_OFFSET.clone();
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), tractor.rotation.y);
                camera.position.copy(tractor.position).add(offset);
                controls.target.copy(tractor.position);
            } else if (currentCameraView === 'follow') {
                // Keep current camera position but look at tractor
                controls.target.copy(tractor.position);
            } else if (currentCameraView === 'firstPerson') {
                // Position camera at tractor's position
                const offset = FIRST_PERSON_OFFSET.clone();
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), tractor.rotation.y-Math.PI/2);
                camera.position.copy(tractor.position).add(offset);
                
                // Look in the direction the tractor is facing
                const lookAtOffset = new THREE.Vector3(10, 2, 0);
                lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), tractor.rotation.y-Math.PI/2);
                controls.target.copy(tractor.position).add(lookAtOffset);
            }
        }

        // Add camera view button handlers
        document.getElementById('thirdPersonView').addEventListener('click', () => {
            currentCameraView = 'thirdPerson';
            updateButtonStates();
        });

        document.getElementById('followView').addEventListener('click', () => {
            currentCameraView = 'follow';
            updateButtonStates();
        });

        document.getElementById('firstPersonView').addEventListener('click', () => {
            currentCameraView = 'firstPerson';
            updateButtonStates();
        });

        function updateButtonStates() {
            document.querySelectorAll('.camera-button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(`${currentCameraView}View`).classList.add('active');
        }

        // Add these variables near the start of the script section, after scene initialization
        let frames = 0;
        let prevTime = performance.now();
        let fpsDisplay = document.getElementById('fpsCounter');

        // Add these new variables for the update counter
        let positionUpdates = 0;
        let updatePrevTime = performance.now();
        let updateDisplay = document.getElementById('updateCounter');

        // Function to update coordinates display
        function updateCoordinates() {
            if (!tractor) return;
            
            const coordsElement = document.getElementById('coordinates');
            coordsElement.innerHTML = `
                Lat: ${tractorPosition.lat.toFixed(4)}°<br>
                Lon: ${tractorPosition.lon.toFixed(4)}°<br>
                Heading: ${tractorPosition.heading.toFixed(1)}°<br>
                Speed: ${tractorPosition.speed.toFixed(1)} km/h<br>
                Time: ${tractorPosition.time.toLocaleString()}<br>
                <hr style="border-color: #666;">
                World X: ${tractorPosition.worldX.toFixed(1)}m<br>
                World Y: ${tractorPosition.worldY.toFixed(1)}m<br>
                World Heading: ${tractorPosition.worldHeading.toFixed(1)}° (N=0°)<br>
                <hr style="border-color: #666;">
                Target X: ${targetPoint.X.toFixed(1)}m<br>
                Target Y: ${targetPoint.Y.toFixed(1)}m<br>
                Target Steering: ${(targetSteeringAngle * 180 / Math.PI).toFixed(1)}°
            `;
        }

        // Modify the animate function to check for tractor existence
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS calculation
            frames++;
            const time = performance.now();
            
            if (time >= prevTime + 1000) {
                const fps = Math.round((frames * 1000) / (time - prevTime));
                fpsDisplay.textContent = `FPS: ${fps}`;
                frames = 0;
                prevTime = time;
            }
            
            if (tractor) { // Only update if tractor exists
                updateCameraPosition();
                controls.update();
                updateCoordinates();
            }
            
            renderer.render(scene, camera);
        }

        // Add control panel handling
        const speedControl = document.getElementById('speedControl');
        const steeringControl = document.getElementById('steeringControl');
        const speedValue = document.getElementById('speedValue');
        const steeringValue = document.getElementById('steeringValue');
        const centerSteeringButton = document.getElementById('centerSteering');

        // Add auto-steering checkbox handling
        const autoSteeringCheckbox = document.getElementById('autoSteeringCheckbox');
        
        // Function to update steering based on target angle
        function updateAutoSteering() {
            if (!tractor || !autoSteeringCheckbox.checked) return;
            
            // Convert target steering angle from radians to degrees
            const targetSteeringDegrees = -(targetSteeringAngle * 180 / Math.PI);
            
            // Update steering control
            steeringControl.value = targetSteeringDegrees;
            
            // Update display value
            if (Math.abs(targetSteeringDegrees) < 0.1) {
                steeringValue.textContent = "Center";
            } else if (targetSteeringDegrees > 0) {
                steeringValue.textContent = `Left ${Math.abs(targetSteeringDegrees).toFixed(3)}°`;
            } else {
                steeringValue.textContent = `Right ${Math.abs(targetSteeringDegrees).toFixed(3)}°`;
            }
            
            // Send control update to server
            sendTractorControls();
        }

        // Disable manual steering control when auto-steering is enabled
        autoSteeringCheckbox.addEventListener('change', function() {
            steeringControl.disabled = this.checked;
            if (!this.checked) {
                // Reset to center when disabling auto-steering
                steeringControl.value = 0;
                steeringValue.textContent = "Center";
                sendTractorControls();
            }
        });

        // Update the existing steering control event listener
        steeringControl.addEventListener('input', () => {
            if (!tractor) return; // Don't update if tractor doesn't exist or auto-steering is enabled
            const value = -parseFloat(steeringControl.value);
            if (Math.abs(value) < 0.1) {
                steeringValue.textContent = "Center";
            } else if (value > 0) {
                steeringValue.textContent = `Left ${Math.abs(value).toFixed(1)}°`;
            } else {
                steeringValue.textContent = `Right ${Math.abs(value).toFixed(1)}°`;
            }
            tractor.setSteeringAngle(value);
            sendTractorControls();
        });

        // Update the center steering button handler
        centerSteeringButton.addEventListener('click', () => {
            if (!tractor || autoSteeringCheckbox.checked) return; // Don't update if auto-steering is enabled
            steeringControl.value = 0;
            steeringValue.textContent = "Center";
            tractor.setSteeringAngle(0);
            sendTractorControls();
        });

        speedControl.addEventListener('input', () => {
            const value = parseFloat(speedControl.value);
            speedValue.textContent = `${value.toFixed(1)} km/h`;
            sendTractorControls();
        });

        // Handle window resizing
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Add function to request path calculation
        function requestPathCalculation() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const config = {
                    type: 'calculatePath',
                    config: {
                        implementWidth: parseFloat(document.getElementById('implementWidth').value)
                    }
                };
                ws.send(JSON.stringify(config));
            }
        }

        // Add after the other control panel variables
        const lookAheadControl = document.getElementById('lookAheadControl');
        const planningDistControl = document.getElementById('planningDistControl');
        const deadzoneControl = document.getElementById('deadzoneControl');
        const lookAheadValue = document.getElementById('lookAheadValue');
        const planningDistValue = document.getElementById('planningDistValue');
        const deadzoneValue = document.getElementById('deadzoneValue');

        // Hide guidance tuning panel initially
        document.getElementById('guidanceTuningPanel').style.display = 'none';

        // Add new function to send guidance parameters
        function sendGuidanceParameters() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const params = {
                    type: 'guidanceParams',
                    lookAheadDistance: parseFloat(lookAheadControl.value),
                    planningDistance: parseFloat(planningDistControl.value),
                    deadzone: parseFloat(deadzoneControl.value) * Math.PI / 180.0  // Convert to radians
                };
                ws.send(JSON.stringify(params));
            }
        }

        // Add event listeners for guidance parameter controls
        lookAheadControl.addEventListener('input', () => {
            const value = parseFloat(lookAheadControl.value);
            lookAheadValue.textContent = `${value.toFixed(1)}`;
            sendGuidanceParameters();
        });

        planningDistControl.addEventListener('input', () => {
            const value = parseFloat(planningDistControl.value);
            planningDistValue.textContent = `${value.toFixed(1)}`;
            sendGuidanceParameters();
        });

        deadzoneControl.addEventListener('input', () => {
            const value = parseFloat(deadzoneControl.value);
            deadzoneValue.textContent = `${value.toFixed(1)}°`;
            sendGuidanceParameters();
        });
    </script>
</body>
</html>
