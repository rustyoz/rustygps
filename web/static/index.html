<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tractor Map</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: monospace;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #info p {
            margin: 5px 0;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        .control-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        .control-item {
            margin-bottom: 5px;
        }
        .control-item label {
            display: inline-block;
            width: 120px;
        }
        .control-item input {
            width: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            color: white;
            border-radius: 3px;
        }
        .control-item span {
            display: inline-block;
            width: 40px;
            text-align: right;
        }
        .control-item button {
            background: #333;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .control-item button:hover {
            background: #444;
        }
        .control-item button:active {
            background: #555;
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 160px;
        }
        #controlPanel {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 200px;
        }
        .center-button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin: 10px auto 0;
            font-family: monospace;
            display: block;
            width: 120px;
        }
        .center-button:hover {
            background: #555;
        }
        #cameraPanel {
            position: absolute;
            top: 150px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 150px;
        }
        .camera-button {
            background: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px 0;
            font-family: monospace;
            display: block;
            width: 100%;
        }
        .camera-button.active {
            background: #666;
        }
        .camera-button:hover {
            background: #555;
        }
        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 250px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }
        #updateCounter {
            position: absolute;
            top: 10px;
            left: 350px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }
        /* Add configuration panel styles */
        .config-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 200px;
            display: none; /* Hide the config panel by default */
        }
        .config-form {
            margin-bottom: 10px;
        }
        .config-group {
            margin-bottom: 10px;
        }
        .config-item {
            margin-bottom: 5px;
        }
        .config-item label {
            display: block;
            margin-bottom: 5px;
        }
        .config-item input[type="number"] {
            width: 100%;
        }
        .config-button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
            font-family: monospace;
            display: block;
            width: 100%;
        }
        .config-button:hover {
            background: #555;
        }
        /* Settings Panel Styles */
        .settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            color: white;
            font-family: monospace;
        }

        .settings-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 200px;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            box-sizing: border-box;
        }

        .settings-categories {
            margin-top: 20px;
        }

        .settings-category {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #333;
            border: none;
            color: white;
            cursor: pointer;
            text-align: left;
            border-radius: 3px;
        }

        .settings-category:hover {
            background: #444;
        }

        .settings-category.active {
            background: #666;
        }

        .settings-content {
            position: absolute;
            left: 200px;
            top: 0;
            right: 0;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
        }

        .settings-group {
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
        }

        .settings-item {
            margin-bottom: 10px;
        }

        .settings-item label {
            display: block;
            margin-bottom: 5px;
        }

        .settings-item input {
            width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            color: white;
            border-radius: 3px;
        }

        .open-settings-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
        }

        .close-settings-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            padding: 0;
        }

        .close-settings-button:hover {
            color: #ccc;
        }

        .settings-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .settings-button {
            background: #444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
        }

        .settings-button:hover {
            background: #555;
        }

        .settings-button.save {
            background: #2a6d2a;
        }

        .settings-button.save:hover {
            background: #368736;
        }

        .settings-button.cancel {
            background: #6d2a2a;
        }

        .settings-button.cancel:hover {
            background: #873636;
        }
        
        /* Axis key panel styles */
        #axisKeyPanel {
            position: absolute;
            bottom: 200px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
            min-width: 150px;
        }
        
        .axis-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .axis-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .axis-x {
            background-color: #ff0000;
        }
        
        .axis-y {
            background-color: #00ff00;
        }
        
        .axis-z {
            background-color: #0000ff;
        }
    </style>
    
    <div id="guidanceTuningPanel" style="position: absolute; bottom: 20px; right: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 5px; font-family: monospace; z-index: 100; min-width: 200px;">
        <h3 style="margin-top: 0;">Guidance Tuning</h3>
        <div class="control-group">
            <label for="lookAheadControl">Look-ahead Distance (m)</label>
            <input type="range" id="lookAheadControl" min="0.1" max="10.0" step="0.1" value="1.0">
            <span id="lookAheadValue" class="control-value">1.0</span>
        </div>
        <div class="control-group">
            <label for="planningDistControl">Planning Distance (m)</label>
            <input type="range" id="planningDistControl" min="1.0" max="10.0" step="0.25" value="3.0">
            <span id="planningDistValue" class="control-value">2.0</span>
        </div>
        <div class="control-group">
            <label for="deadzoneControl">Deadzone (degrees)</label>
            <input type="range" id="deadzoneControl" min="0.0" max="5.0" step="0.1" value="1.0">
            <span id="deadzoneValue" class="control-value">1.0</span>
        </div>
    </div>
    <!-- Add settings panel -->
    <div id="settingsPanel" class="settings-panel">
        <div class="settings-sidebar">
            <h3>Settings</h3>
            <div class="settings-categories">
                <button class="settings-category active" data-category="tractor">Tractor</button>
                <button class="settings-category" data-category="implement">Implement</button>
                <button class="settings-category" data-category="gps">GPS</button>
                <button class="settings-category" data-category="planner">Planner</button>
                <button class="settings-category" data-category="guidance">Guidance</button>
            </div>
        </div>
        <div class="settings-content">
            <div class="settings-category-content" id="tractor-settings">
                <h2>Tractor Settings</h2>
                <div class="settings-group">
                    <h3>Dimensions</h3>
                    <div class="settings-item">
                        <label for="settings-wheelbase">Wheelbase (meters):</label>
                        <input type="number" id="settings-wheelbase" value="2.86" step="0.1" min="0.1">
                    </div>
                    <div class="settings-item">
                        <label for="settings-hitchOffset">Hitch Offset (meters):</label>
                        <input type="number" id="settings-hitchOffset" value="1.0" step="0.1" min="0.1">
                    </div>
                </div>
            </div>
            <div class="settings-category-content" id="implement-settings" style="display: none;">
                <h2>Implement Settings</h2>
                <div class="settings-group">
                    <h3>Dimensions</h3>
                    <div class="settings-item">
                        <label for="settings-implementLength">Length (meters):</label>
                        <input type="number" id="settings-implementLength" value="5.0" step="0.1" min="0.1">
                    </div>
                    <div class="settings-item">
                        <label for="settings-implementWidth">Width (meters):</label>
                        <input type="number" id="settings-implementWidth" value="10.0" step="0.1" min="0.1">
                    </div>
                </div>
            </div>
            <div class="settings-category-content" id="gps-settings" style="display: none;">
                <h2>GPS Settings</h2>
                <div class="settings-group">
                    <h3>Position</h3>
                    <div class="settings-item">
                        <label for="settings-gpsLat">Latitude:</label>
                        <input type="number" id="settings-gpsLat" value="-36.8013" step="0.0001">
                    </div>
                    <div class="settings-item">
                        <label for="settings-gpsLon">Longitude:</label>
                        <input type="number" id="settings-gpsLon" value="142.3142" step="0.0001">
                    </div>
                </div>
            </div>
            <div class="settings-category-content" id="planner-settings" style="display: none;">
                <h2>Planner Settings</h2>
                <div class="settings-group">
                    <h3>Path Planning</h3>
                    <div class="settings-item">
                        <label for="settings-planningDistance">Planning Distance (m):</label>
                        <input type="number" id="settings-planningDistance" value="3.0" step="0.25" min="1.0" max="10.0">
                    </div>
                </div>
            </div>
            <div class="settings-category-content" id="guidance-settings" style="display: none;">
                <h2>Guidance Settings</h2>
                <div class="settings-group">
                    <h3>Parameters</h3>
                    <div class="settings-item">
                        <label for="settings-lookAhead">Look-ahead Distance (m):</label>
                        <input type="number" id="settings-lookAhead" value="2.0" step="0.1" min="0.1" max="10.0">
                    </div>
                    <div class="settings-item">
                        <label for="settings-deadzone">Deadzone (degrees):</label>
                        <input type="number" id="settings-deadzone" value="1.0" step="0.1" min="0.0" max="5.0">
                    </div>
                </div>
            </div>
        </div>
        <button id="closeSettingsX" class="close-settings-button">×</button>
        <div class="settings-buttons">
            <button id="closeSettings" class="settings-button cancel">Cancel</button>
            <button id="saveSettings" class="settings-button save">Save</button>
        </div>
    </div>
    <button id="openSettings" class="open-settings-button">⚙️</button>
    <div id="axisKeyPanel">
        <h3 style="margin-top: 0;">Axis Legend</h3>
        <div class="axis-item">
            <div class="axis-color axis-x"></div>
            <span>X-Axis (East)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color axis-y"></div>
            <span>Y-Axis (North)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color axis-z"></div>
            <span>Z-Axis (Up)</span>
        </div>
    </div>
    <div id="coordinates">
        Lat: 0.000°<br>
        Lon: 0.000°<br>
        Heading: 0.0°<br>
        Speed: 0.0 km/h
    </div>
    <div id="fpsCounter">
        FPS: 0
    </div>
    <div id="updateCounter">
        Updates/s: 0
    </div>
    <div id="controlPanel">
        <h3 style="margin-top: 0;">Tractor Controls</h3>
        <div class="control-group">
            <label for="speedControl">Speed (km/h)</label>
            <input type="range" id="speedControl" min="0" max="30" step="0.1" value="0">
            <span id="speedValue" class="control-value">0.0</span>
        </div>
        <div class="control-group">
            <label for="steeringControl">
                Steering
                <label style="display: inline; margin-left: 10px;">
                    <input type="checkbox" id="autoSteeringCheckbox"> Auto
                </label>
            </label>
            <div style="display: flex; justify-content: space-between; font-size: 0.8em; margin-bottom: 2px;">
                <span>Left 30°</span>
                <span>Right 30°</span>
            </div>
            <input type="range" id="steeringControl" min="-30" max="30" step="0.1" value="0">
            <span id="steeringValue" style="width: 90px;" class="control-value">Center</span>
        </div>
        <button id="centerSteering" class="center-button">Center Steering</button>
        <button id="resetSimulation" class="center-button" style="margin-top: 10px; background-color: #d44;">Reset Simulation</button>
    </div>
    <div id="cameraPanel">
        <h3 style="margin-top: 0;">Camera View</h3>
        <button id="thirdPersonView" class="camera-button active">Third Person</button>
        <button id="followView" class="camera-button">Follow</button>
        <button id="firstPersonView" class="camera-button">First Person</button>
        <button id="birdsEyeView" class="camera-button">Birds Eye</button>
        <button id="resetCamera" class="camera-button" style="background-color: #d44; color: white;">Reset Camera</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/ImageBitmapLoader.js"></script>
    <script src="tractormodel.js"></script>
    <script src="implementmodel.js"></script>
    <script>
        // Initialize Three.js scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create guidance arrow
        const guidanceArrowLength = 20;
        const guidanceArrowColor = 0x00ff00; // green
        const guidanceArrow = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0), // direction - will be updated
            new THREE.Vector3(0, 1, 0), // origin - will be updated
            guidanceArrowLength,
            guidanceArrowColor,
            5, // headLength
            3  // headWidth
        );
        guidanceArrow.renderOrder = 2; // Ensure arrow renders above other elements
        scene.add(guidanceArrow);
        camera.up.set(0, 0, 1);

        // Initialize OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movements
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true; // Enable proper panning in the XY plane
        controls.minDistance = 5;
        controls.maxDistance = 5000;
        controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below ground
        
        // Set the camera's up vector to align with the z-axis (up in ENU)
        camera.up.set(0, 0, 1);
        
        // Add event listener to detect user panning in birds eye view
        controls.addEventListener('change', function() {
            // Set panned flag if we're in birds eye view
            if (currentCameraView === 'birdsEye') {
                birdViewPanned = true;
                controls.screenSpacePanning = true;
            } 
            updateArrowScale();
        });

        // Add reset camera function
        function resetCamera() {
            controls.reset();
            camera.position.set(200, 200, 200);
            // Set camera up vector to z-axis (up in ENU coordinates)
            camera.up.set(0, 0, 1);
            if (tractor) {
                controls.target.copy(tractor.position);
            }
            // Reset birds eye view panned flag
            birdViewPanned = false;
            // Update arrow scale after camera reset if arrows exist
            if (arrowX && arrowY && arrowZ) {
                updateArrowScale();
            }
        }

        // Add event listener for reset button
        document.getElementById('resetCamera').addEventListener('click', resetCamera);

        // Hide UI elements initially
        document.getElementById('coordinates').style.display = 'none';
        document.getElementById('fpsCounter').style.display = 'none';
        document.getElementById('updateCounter').style.display = 'none';
        document.getElementById('controlPanel').style.display = 'none';
        document.getElementById('cameraPanel').style.display = 'none';
        document.getElementById('guidanceTuningPanel').style.display = 'none';
        document.getElementById('axisKeyPanel').style.display = 'none';

        // Configuration handling
        let ws;
        let configSent = false;
        let tractor = null;
        let implement = null;
        let animationStarted = false;
        
        // Add these variables to store guidance information
        let targetPoint = { X: 0, Y: 0 };
        let targetSteeringAngle = 0;
        
        // Initialize WebSocket connection
        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.host}/ws`);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                // Automatically start simulation instead of waiting for button click
                autoStartSimulation();
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'position' && tractor) {
                    // Count position updates
                    positionUpdates++;
                    
                    // Calculate updates per second every second
                    const time = performance.now();
                    if (time >= updatePrevTime + 1000) {
                        const updatesPerSec = Math.round((positionUpdates * 1000) / (time - updatePrevTime));
                        updateDisplay.textContent = `Updates/s: ${updatesPerSec}`;
                        positionUpdates = 0;
                        updatePrevTime = time;
                    }

                    tractorPosition = {
                        lat: data.tractorPos.Lat,
                        lon: data.tractorPos.Lon,
                        heading: data.tractorPos.Heading,
                        speed: data.tractorPos.Speed,  
                        time: new Date(data.tractorPos.Time),
                        worldX: data.tractorWorldPos.X,
                        worldY: data.tractorWorldPos.Y,
                        worldHeading: data.tractorWorldPos.Heading
                    };

                    implementPosition = {
                        lat: data.implementPos.Lat,
                        lon: data.implementPos.Lon,
                        heading: data.implementPos.Heading,
                        speed: data.implementPos.Speed,  
                        time: new Date(data.implementPos.Time),
                        worldX: data.implementWorldPos.X,
                        worldY: data.implementWorldPos.Y,
                        worldHeading: data.implementWorldPos.Heading
                    };

                    // Add coverage line if speed is not 0 and coverage line data exists
                    if (data.implementCoverageLine && data.tractorPos.Speed !== 0) {
                        addCoverageLine(data.implementCoverageLine);
                    }

                    articulationAngle = implementPosition.worldHeading - tractorPosition.worldHeading;
                    
                    // Update tractor position and rotation
                    tractor.position.x = tractorPosition.worldX;
                    tractor.position.y = tractorPosition.worldY;
                    tractor.position.z = 0;
                    tractor.rotation.z = tractorPosition.worldHeading;

                    // Update implement angle
                    tractor.setImplementAngle(articulationAngle);

                    // Update guidance arrow origin to match tractor position
                    guidanceArrow.position.set(tractorPosition.worldX, tractorPosition.worldY, 1);

                    // Update path points
                    tractorPathPoints.push(new THREE.Vector3(tractorPosition.worldX, tractorPosition.worldY, 0.1));
                    tractorPathGeometry.setFromPoints(tractorPathPoints);

                    // Update implement path points
                    implementPathPoints.push(new THREE.Vector3(implementPosition.worldX, implementPosition.worldY, 0.1));
                    implementPathGeometry.setFromPoints(implementPathPoints);
                }
                if (data.type === 'field') {
                    // Update field boundary
                    fieldBoundaryPoints.length = 0;
                    data.boundary.forEach(point => {
                        fieldBoundaryPoints.push(new THREE.Vector3(point.X, point.Y, 0.1));
                    });
                    // Close the boundary
                    if (data.boundary.length > 0) {
                        fieldBoundaryPoints.push(new THREE.Vector3(
                            data.boundary[0].X, data.boundary[0].Y, 0.1
                        ));
                    }
                    fieldBoundaryGeometry.setFromPoints(fieldBoundaryPoints);
                    
                    // Update inner boundary
                    innerBoundaryPoints.length = 0;
                    if (data.innerBoundary && data.innerBoundary.length > 0) {
                        data.innerBoundary.forEach(point => {
                            innerBoundaryPoints.push(new THREE.Vector3(point.X, point.Y, 0.1));
                        });
                        // Close the inner boundary
                        innerBoundaryPoints.push(new THREE.Vector3(
                            data.innerBoundary[0].X, data.innerBoundary[0].Y, 0.1
                        ));
                    }
                    innerBoundaryGeometry.setFromPoints(innerBoundaryPoints);
                    
                    
                    
                    // Request path calculation
                    requestPathCalculation();
                }
                else if (data.type === 'path') {
                    // Update AB line path
                    abPathPoints.length = 0;

                    console.log("path", data)
                    
                    // Remove existing line segments
                    while (abPathGroup.children.length > 0) {
                        const line = abPathGroup.children[0];
                        abPathGroup.remove(line);
                        line.geometry.dispose();
                        line.material.dispose();
                    }
                    
                    // Store points with their full data including color
                    const pointsWithData = data.points;
                    
                    // Add points to the array for other uses
                    pointsWithData.forEach(point => {
                        abPathPoints.push(new THREE.Vector3(point.X, point.Y, 0.1));
                    });
                    
                    // Create colored line segments between consecutive points
                    for (let i = 1; i < pointsWithData.length; i++) {
                        const previousPoint = pointsWithData[i-1];
                        const currentPoint = pointsWithData[i];
                        
                        // Use specified color if available, otherwise use default purple
                        const lineColor = currentPoint.Color ? 
                            new THREE.Color(currentPoint.Color) : 
                            new THREE.Color(0x800080); // Default purple
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: lineColor,
                            linewidth: 2,
                            side: THREE.DoubleSide
                        });
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(previousPoint.X, previousPoint.Y, 0.1),
                            new THREE.Vector3(currentPoint.X, currentPoint.Y, 0.1)
                        ]);
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.renderOrder = 1;
                        line.material.depthTest = false;
                        line.frustumCulled = false;
                        
                        abPathGroup.add(line);
                    }
                    
                    // Update markers if there are points
                    if (abPathPoints.length >= 2) {
                        // Position start marker at first point
                        startMarker.position.set(abPathPoints[0].x, abPathPoints[0].y, 0.1);
                        
                        // Position end marker at last point
                        endMarker.position.set(
                            abPathPoints[abPathPoints.length - 1].x,
                            abPathPoints[abPathPoints.length - 1].y,
                            0.1
                        );
                    }

                    if (data.controlPoints) {
                        controlPathPoints.length = 0;
                        data.controlPoints.forEach(point => {
                            controlPathPoints.push(new THREE.Vector3(point.X, point.Y, 0.1));
                        });
                        controlPathGeometry.setFromPoints(controlPathPoints);
                    }
                } else if (data.type === 'guidance') {
                    // Update guidance arrow direction
                    if (tractor) {
                        targetPoint = data.targetPoint;
                        targetSteeringAngle = data.steeringAngle;
                        const targetPoint3D = new THREE.Vector3(data.targetPoint.X, data.targetPoint.Y, 1);
                        const tractorPos = new THREE.Vector3(tractorPosition.worldX, tractorPosition.worldY, 1);
                        const direction = targetPoint3D.clone().sub(tractorPos).normalize();
                        guidanceArrow.setDirection(direction);
                        guidanceArrow.setLength(guidanceArrowLength);
                        updateCoordinates(); // Update display when guidance info changes
                        updateAutoSteering(); // Update auto-steering if enabled
                    }
                }

                // Add reset simulation handler
                document.getElementById('resetSimulation').addEventListener('click', function() {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Reset speed and steering controls
                        speedControl.value = 0;
                        speedValue.textContent = '0.0';
                        steeringControl.value = 0;
                        steeringValue.textContent = 'Center';
                        steeringControl.disabled = false;
                        autoSteeringCheckbox.checked = false;
                        tractor.setImplementAngle(0);
                        tractor.setSteeringAngle(0);

                        // Clear path arrays
                        tractorPathPoints.length = 0;
                        implementPathPoints.length = 0;
                        abPathPoints.length = 0;
                        
                        // Reset path geometries
                        tractorPathGeometry.setFromPoints(tractorPathPoints);
                        implementPathGeometry.setFromPoints(implementPathPoints);
                        
                        // Send reset command to server
                        ws.send(JSON.stringify({type: 'reset'}));
                    }
                });
            };
            
            ws.onclose = function() {
                console.log('WebSocket disconnected, attempting to reconnect...');
                setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        // Connect to WebSocket when page loads
        connectWebSocket();

        // Function to auto-start the simulation
        function autoStartSimulation() {
            if (!configSent && ws && ws.readyState === WebSocket.OPEN) {
                // Try to load settings from cookies first
                loadSettingsFromCookies();
                
                const config = {
                    type: 'config',
                    tractor: {
                        wheelbase: parseFloat(document.getElementById('settings-wheelbase').value),
                        hitchOffset: parseFloat(document.getElementById('settings-hitchOffset').value)
                    },
                    implement: {
                        length: parseFloat(document.getElementById('settings-implementLength').value),
                        width: parseFloat(document.getElementById('settings-implementWidth').value)
                    }
                };

                ws.send(JSON.stringify(config));
                configSent = true;
                
                // Create 3D models with configured dimensions
                createModels(config);
                
                // Make sure all UI elements are visible
                document.getElementById('coordinates').style.display = 'block';
                document.getElementById('fpsCounter').style.display = 'block';
                document.getElementById('updateCounter').style.display = 'block';
                document.getElementById('controlPanel').style.display = 'block';
                document.getElementById('cameraPanel').style.display = 'block';
                document.getElementById('guidanceTuningPanel').style.display = 'block';
                document.getElementById('axisKeyPanel').style.display = 'block';
                
                
                // Send initial guidance parameters
                sendGuidanceParameters();
                
                // Start the animation loop if not already started
                if (!animationStarted) {
                    animationStarted = true;
                    animate();
                }

                // Request field boundary after configuration
                ws.send(JSON.stringify({type: 'getField'}));
            }
        }

        // Cookie functions for settings
        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = name + '=' + JSON.stringify(value) + ';expires=' + expires.toUTCString() + ';path=/';
        }

        function getCookie(name) {
            const nameEQ = name + '=';
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    try {
                        return JSON.parse(c.substring(nameEQ.length, c.length));
                    } catch (e) {
                        console.error('Error parsing cookie:', e);
                        return null;
                    }
                }
            }
            return null;
        }

        // Load settings from cookies
        function loadSettingsFromCookies() {
            const settings = getCookie('tractorSettings');
            if (settings) {
                // Load values if they exist
                if (settings.tractor) {
                    if (settings.tractor.wheelbase) {
                        document.getElementById('settings-wheelbase').value = settings.tractor.wheelbase;
                    }
                    if (settings.tractor.hitchOffset) {
                        document.getElementById('settings-hitchOffset').value = settings.tractor.hitchOffset;
                    }
                }
                
                if (settings.implement) {
                    if (settings.implement.length) {
                       document.getElementById('settings-implementLength').value = settings.implement.length;
                    }
                    if (settings.implement.width) {
                        document.getElementById('settings-implementWidth').value = settings.implement.width;
                    }
                }
                
                if (settings.guidance) {
                    if (settings.guidance.lookAhead) {
                        document.getElementById('lookAheadControl').value = settings.guidance.lookAhead;
                        document.getElementById('settings-lookAhead').value = settings.guidance.lookAhead;
                        lookAheadValue.textContent = settings.guidance.lookAhead;
                    }
                    if (settings.guidance.planningDistance) {
                        document.getElementById('planningDistControl').value = settings.guidance.planningDistance;
                        document.getElementById('settings-planningDistance').value = settings.guidance.planningDistance;
                        planningDistValue.textContent = settings.guidance.planningDistance;
                    }
                    if (settings.guidance.deadzone) {
                        document.getElementById('deadzoneControl').value = settings.guidance.deadzone;
                        document.getElementById('settings-deadzone').value = settings.guidance.deadzone;
                        deadzoneValue.textContent = settings.guidance.deadzone + '°';
                    }
                }

                console.log('Settings loaded from cookies:', settings);
            }
        }

        // Save settings to cookies
        function saveSettingsToCookies() {
            const settings = {
                tractor: {
                    wheelbase: parseFloat(document.getElementById('settings-wheelbase').value),
                    hitchOffset: parseFloat(document.getElementById('settings-hitchOffset').value)
                },
                implement: {
                    length: parseFloat(document.getElementById('settings-implementLength').value),
                    width: parseFloat(document.getElementById('settings-implementWidth').value)
                },
                gps: {
                    lat: parseFloat(document.getElementById('settings-gpsLat').value),
                    lon: parseFloat(document.getElementById('settings-gpsLon').value)
                },
                guidance: {
                    lookAhead: parseFloat(document.getElementById('settings-lookAhead').value),
                    planningDistance: parseFloat(document.getElementById('settings-planningDistance').value),
                    deadzone: parseFloat(document.getElementById('settings-deadzone').value)
                }
            };
            
            setCookie('tractorSettings', settings, 365); // Save for 1 year
            console.log('Settings saved to cookies:', settings);
            
            return settings;
        }

        // Add function to send tractor controls
        function sendTractorControls() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const controls = {
                    type: 'control',
                    speed: parseFloat(speedControl.value),
                    steeringAngle: parseFloat(steeringControl.value)
                };
                ws.send(JSON.stringify(controls));
            }
        }

        function createModels(config) {
            // Create tractor with configured dimensions
            tractor = tractorModel(config.tractor.wheelbase, config.tractor.hitchOffset);
            
            // Create implement with configured dimensions
            implement = implementModel(config.implement.width, config.implement.length);
            
            // Add implement to tractor
            addImplement(tractor, implement);
            
            // Add to scene
            scene.add(tractor);
            
            // Position camera for better view
            camera.position.set(200, 200, 200);
            camera.lookAt(tractor.position.x, tractor.position.y, tractor.position.z+10);
            camera.up.set(0, 0, 1); // Set Z as up direction
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 0, 10);
            scene.add(directionalLight);
        }
        
        // Replace the ground plane creation with this tile-based system
        // 36°48'04.7"S 142°18'51.3"E
        const METERS_PER_TILE = 4.78 * 1000; // 4.78km at zoom level 13
        const TILE_SIZE = METERS_PER_TILE; // Scene units are now in meters
        const initialLat = -36.8013;
        const initialLon = 142.3142;
        const zoom = 13; // Adjust zoom level as needed

        // Update mock data to include heading and speed
        let tractorPosition = {
            lat: -36.8013,
            lon: 142.3142,
            worldX: 0,
            worldY: 0,
            worldHeading: 0,
            heading: 45.0,
            speed: 8.5,
            time: new Date()
        };

        function lon2tile(lon, zoom) {
            return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
        }

        function lat2tile(lat, zoom) {
            return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
        }

        // Function to calculate the center latitude of a tile
        function tile2lat(y, z) {
            const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
            return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
        }
        
        // Function to calculate the center longitude of a tile
        function tile2lon(x, z) {
            return x / Math.pow(2, z) * 360 - 180;
        }

        async function loadMapTile(layer, x, y, z, time) {
            // open street map
            const baseUrl = 'https://tile.openstreetmap.org';
            const url = `${baseUrl}/${z}/${x}/${y}.png`;

            try {
                // Use ImageBitmapLoader instead of fetch + createImageBitmap
                const loader = new THREE.ImageBitmapLoader();
                // Set crossOrigin to Anonymous to avoid CORS issues
                loader.setCrossOrigin('anonymous');
                // Enable image bitmap creation
                loader.setOptions({ imageOrientation: 'flipY' });
                
                return await loader.loadAsync(url);
            } catch (error) {
                console.error('Error loading map tile:', error);
                throw error;
            }
        }

        // Convert lat/lon to world coordinates
        function latLonToWorld(lat, lon, centerLat, centerLon) {
            // Earth radius in meters
            const R = 6378137;
            
            // Convert to radians
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            const centerLatRad = centerLat * Math.PI / 180;
            const centerLonRad = centerLon * Math.PI / 180;
            
            // Calculate X position (East-West)
            const x = R * (lonRad - centerLonRad) * Math.cos(centerLatRad);
            
            // Calculate Y position (North-South)
            const y = R * (latRad - centerLatRad);
            
            return { x, y };
        }

        // Load initial tiles
        async function loadInitialTiles() {
            const centerTileX = lon2tile(initialLon, zoom);
            const centerTileY = lat2tile(initialLat, zoom);
            
            // Calculate the center latitude and longitude of the center tile
            const centerTileLat = tile2lat(centerTileY + 0.5, zoom);
            const centerTileLon = tile2lon(centerTileX + 0.5, zoom);
            
            // Calculate the world offset between the center tile and initial tractor position
            const tileCenter = latLonToWorld(centerTileLat, centerTileLon, initialLat, initialLon);
            const tileOffset = { x: tileCenter.x, y: tileCenter.y };
            
            console.log('Tile center lat/lon:', centerTileLat, centerTileLon);
            console.log('Initial tractor lat/lon:', initialLat, initialLon);
            console.log('Calculated tile offset:', tileOffset);
            
            // Load 3x3 grid of tiles
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const tileX = centerTileX + i;
                    const tileY = centerTileY + j;
                    
                    // Convert to world coordinates relative to initial tractor position
                    const tileWorldPos = {
                        x: tileOffset.x + i * TILE_SIZE,
                        y: tileOffset.y - j * TILE_SIZE // Flip Y coordinate j increases downwards
                    };
                    
                    // Load tile image data using the ImageBitmapLoader
                    try {
                        const tileImage = await loadMapTile('s2_ls_combined', tileX, tileY, zoom, null);
                        const tileTexture = new THREE.Texture(tileImage);
                        
                        // Image has already been flipped by the loader options
                        tileTexture.needsUpdate = true;
                        
                        // Create tile mesh
                        const tileGeometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
                        tileGeometry.attributes.uv.needsUpdate = true;
                        
                        const tileMaterial = new THREE.MeshBasicMaterial({ map: tileTexture });
                        const tileMesh = new THREE.Mesh(tileGeometry, tileMaterial);
                        
                        // Position the tile at its calculated world position
                        tileMesh.position.set(tileWorldPos.x, tileWorldPos.y, 0);
                        
                        scene.add(tileMesh);
                        
                        // Add red wireframe to show tile boundaries
                        const edgesGeometry = new THREE.EdgesGeometry(tileGeometry);
                        const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
                        const wireframe = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                        wireframe.position.copy(tileMesh.position);
                        wireframe.rotation.copy(tileMesh.rotation);
                        wireframe.renderOrder = 1; // Ensure wireframe renders above the tile
                        scene.add(wireframe);
                    } catch (error) {
                        console.error(`Failed to load tile at ${tileX},${tileY}:`, error);
                    }
                }
            }
            
            // Create grid of grey lines
            createGrid();
        }
        
        // Function to create a grid of grey lines
        function createGrid() {
            const gridSize = 5000; // 5km in each direction
            const gridSpacing = 100; // 100m spacing
            const gridColor = 0x888888; // Grey color
            const gridOpacity = 0.6; // Semi-transparent
            
            // Create grid material
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: gridColor, 
                transparent: true, 
                opacity: gridOpacity,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create grid geometry
            const gridGroup = new THREE.Group();
            
            // Create horizontal lines (along X axis)
            for (let y = -gridSize; y <= gridSize; y += gridSpacing) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [
                    new THREE.Vector3(-gridSize, y, 0.1),
                    new THREE.Vector3(gridSize, y, 0.1)
                ];
                geometry.setFromPoints(vertices);
                const line = new THREE.Line(geometry, gridMaterial);
                gridGroup.add(line);
            }
            
            // Create vertical lines (along Y axis)
            for (let x = -gridSize; x <= gridSize; x += gridSpacing) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [
                    new THREE.Vector3(x, -gridSize, 0.1),
                    new THREE.Vector3(x, gridSize, 0.1)
                ];
                geometry.setFromPoints(vertices);
                const line = new THREE.Line(geometry, gridMaterial);
                gridGroup.add(line);
            }
            
            // Add grid to scene
            gridGroup.renderOrder = 1; // Ensure grid renders above ground
            scene.add(gridGroup);
        }

        // Remove the old ground plane code and call loadInitialTiles
        loadInitialTiles();

        // Define global arrow variables
        let arrowX, arrowY, arrowZ;
        
        // Function to scale coordinate arrows based on camera height
        function updateArrowScale() {
            if (!camera) return;
            
            // Calculate distance from camera to origin
            const cameraDistance = camera.position.length();
            
            // Base length - adjust these values to change the relative size
            const baseLength = cameraDistance * 0.15; // 15% of camera distance
            const baseHeadLength = baseLength * 0.1;  // 10% of arrow length
            const baseHeadWidth = baseHeadLength * 0.6; // 60% of head length
            
            // Set minimum and maximum sizes to prevent arrows from becoming too small or too large
            const minLength = 50;
            const maxLength = 2000;
            const arrowLength = THREE.MathUtils.clamp(baseLength, minLength, maxLength);
            const headLength = THREE.MathUtils.clamp(baseHeadLength, minLength * 0.1, maxLength * 0.1);
            const headWidth = THREE.MathUtils.clamp(baseHeadWidth, minLength * 0.06, maxLength * 0.06);
            
            // Update each arrow
            if (arrowX) {
                arrowX.setLength(arrowLength, headLength, headWidth);
            }
            if (arrowY) {
                arrowY.setLength(arrowLength, headLength, headWidth);
            }
            if (arrowZ) {
                arrowZ.setLength(arrowLength, headLength, headWidth);
            }
        }
        
        // Create and add coordinate system arrows (ENU - East North Up)
        function createCoordinateAxes() {
            // X axis - East (Red)
            arrowX = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 0, 0),
                150, // length
                0xff0000, // red
                15, // head length
                10 // head width
            );
            scene.add(arrowX);

            // Y axis - North (Green)
            arrowY = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 0),
                150, // length
                0x00ff00, // green
                15, // head length
                10 // head width
            );
            scene.add(arrowY);

            // Z axis - Up (Blue)
            arrowZ = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, 0),
                150, // length
                0x0000ff, // blue
                15, // head length
                10 // head width
            );
            scene.add(arrowZ);
        }
        
        // Create the coordinate axes
        createCoordinateAxes();
        
        // Store arrows in an array for easier access
        const coordinateArrows = [arrowX, arrowY, arrowZ];
        
        // Now that arrows are created, add event listeners for camera changes
        controls.addEventListener('change', updateArrowScale);
        // Initial scale update
        updateArrowScale();

        // Add after scene initialization and before tractor model creation
        // Create line for tractor path
        const tractorPathPoints = [];
        const tractorPathGeometry = new THREE.BufferGeometry();
        const tractorPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, // green
            linewidth: 2,  // Note: linewidth only works in WebGLRenderer2
            side: THREE.DoubleSide
        });
        const tractorPath = new THREE.Line(tractorPathGeometry, tractorPathMaterial);
        tractorPath.renderOrder = 1; // Ensure path renders above ground
        tractorPath.material.depthTest = false; // Prevent z-fighting with ground
        tractorPath.frustumCulled = false;
        scene.add(tractorPath);

        // implement path
        const implementPathPoints = [];
        const implementPathGeometry = new THREE.BufferGeometry();
        const implementPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, // red
            linewidth: 2,  // Note: linewidth only works in WebGLRenderer2
            side: THREE.DoubleSide
        });


        const implementPath = new THREE.Line(implementPathGeometry, implementPathMaterial);
        implementPath.renderOrder = 1; // Ensure path renders above ground
        implementPath.material.depthTest = false; // Prevent z-fighting with ground
        implementPath.frustumCulled = false;
        scene.add(implementPath);

        // Add after the implement path creation and before the WebSocket message handler
        // Create field boundary line
        const fieldBoundaryPoints = [];
        const fieldBoundaryGeometry = new THREE.BufferGeometry();
        const fieldBoundaryMaterial = new THREE.LineBasicMaterial({ 
            color: 0x0000ff, // blue
            linewidth: 2,
            side: THREE.DoubleSide
        });
        const fieldBoundary = new THREE.Line(fieldBoundaryGeometry, fieldBoundaryMaterial);
        fieldBoundary.renderOrder = 1;
        fieldBoundary.material.depthTest = false;
        fieldBoundary.frustumCulled = false;
        scene.add(fieldBoundary);

        // Create inner boundary line
        const innerBoundaryPoints = [];
        const innerBoundaryGeometry = new THREE.BufferGeometry();
        const innerBoundaryMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, // green
            linewidth: 2,
            side: THREE.DoubleSide
        });
        const innerBoundary = new THREE.Line(innerBoundaryGeometry, innerBoundaryMaterial);
        innerBoundary.renderOrder = 1;
        innerBoundary.material.depthTest = false;
        innerBoundary.frustumCulled = false;
        scene.add(innerBoundary);

        // Create AB line path
        const abPathPoints = [];
        const abPathGroup = new THREE.Group(); // Create a group to hold colored segments
        scene.add(abPathGroup);

        const controlPathPoints = [];
        const controlPathGeometry = new THREE.BufferGeometry();
        const controlPathMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, // red
            linewidth: 2,  // Note: linewidth only works in WebGLRenderer2
            side: THREE.DoubleSide
        });
        const controlPath = new THREE.Line(controlPathGeometry, controlPathMaterial);
        controlPath.renderOrder = 1; // Ensure path renders above ground
        controlPath.material.depthTest = false; // Prevent z-fighting with ground
        controlPath.frustumCulled = false;
        scene.add(controlPath);

        // Create start marker (green triangle)
        const startMarkerGeometry = new THREE.BufferGeometry();
        const startMarkerVertices = new Float32Array([
            0, 1, 0,    // top
            -0.866, -0.5, 0,  // bottom left
            0.866, -0.5, 0    // bottom right
        ]);
        startMarkerGeometry.setAttribute('position', new THREE.BufferAttribute(startMarkerVertices, 3));
        const startMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const startMarker = new THREE.Mesh(startMarkerGeometry, startMarkerMaterial);
        startMarker.scale.set(2, 2, 2);
        scene.add(startMarker);

        // Create end marker (red square)
        const endMarkerGeometry = new THREE.PlaneGeometry(2, 2);
        const endMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
        scene.add(endMarker);

        // Create collection for coverage lines
        const coverageLines = [];
        const coverageLineMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff69b4, // pink
            linewidth: 2,
            side: THREE.DoubleSide
        });

        // Function to add new coverage line
        function addCoverageLine(points) {
            // Remove oldest line if we've reached the limit
            if (coverageLines.length >= 1000) {
                const oldestLine = coverageLines.shift(); // Remove first (oldest) line
                scene.remove(oldestLine); // Remove from scene
                oldestLine.geometry.dispose(); // Clean up geometry
                oldestLine.material.dispose(); // Clean up material
            }

            const geometry = new THREE.BufferGeometry();
            const vertices = points.map(p => new THREE.Vector3(p.X, p.Y, 0.1));
            geometry.setFromPoints(vertices);
            
            const line = new THREE.Line(geometry, coverageLineMaterial);
            line.renderOrder = 1;
            line.material.depthTest = false;
            line.frustumCulled = false;
            
            coverageLines.push(line);
            scene.add(line);
        }

        // Add after scene initialization
        let currentCameraView = 'thirdPerson'; // Global variable for camera view
        let birdViewPanned = false; // Track if user has panned in birds eye view
        
        // Camera position constants
        const THIRD_PERSON_OFFSET = new THREE.Vector3(-20, 0, 10);
        const FIRST_PERSON_OFFSET = new THREE.Vector3(0, 0, 2);
        const BIRDS_EYE_HEIGHT = 50; // Default height for birds-eye view
        let birdsEyeHeight = BIRDS_EYE_HEIGHT; // Variable height that can be adjusted
        
        // Update camera position based on view mode
        function updateCameraPosition() {
            if (!tractor) return; // Don't update camera if tractor doesn't exist yet
            
            // Always ensure camera up vector is aligned with z-axis (up in ENU)
            camera.up.set(0, 0, 1);
            
            if (currentCameraView === 'thirdPerson') {
                // Position camera behind tractor
                const offset = THIRD_PERSON_OFFSET.clone();
                offset.applyAxisAngle(new THREE.Vector3(0, 0, 1), tractor.rotation.z);
                camera.position.copy(tractor.position).add(offset);
                controls.target.copy(tractor.position);
            } else if (currentCameraView === 'follow') {
                // Keep current camera position but look at tractor
                controls.target.copy(tractor.position);
            } else if (currentCameraView === 'firstPerson') {
                // Position camera at tractor's position
                const offset = FIRST_PERSON_OFFSET.clone();
                offset.applyAxisAngle(new THREE.Vector3(0, 0, 1), tractor.rotation.z-Math.PI/2);
                camera.position.copy(tractor.position).add(offset);
                
                // Look in the direction the tractor is facing
                const lookAtOffset = new THREE.Vector3(10, 0, 2);
                lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 0, 1), tractor.rotation.z-Math.PI/2);
                controls.target.copy(tractor.position).add(lookAtOffset);
            } else if (currentCameraView === 'birdsEye') {
                // Only update position if user hasn't panned
                if (!birdViewPanned) {
                    // Position camera directly above tractor with adjustable height
                    camera.position.copy(tractor.position).add(new THREE.Vector3(0, 0, birdsEyeHeight));
                    
                    // Look down at tractor
                    controls.target.copy(tractor.position);
                    
                    // For birds-eye view, orient camera with tractor heading
                    const tractorHeading = -tractor.rotation.z+Math.PI/2;
                    // Up vector is in the XY plane, perpendicular to the direction of travel
                    camera.up.set(Math.sin(tractorHeading), Math.cos(tractorHeading), 0);
                }
            }
        }

        // Add camera view button handlers
        document.getElementById('thirdPersonView').addEventListener('click', () => {
            currentCameraView = 'thirdPerson';
            controls.mouseButtons = { LEFT: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            
            updateButtonStates();
        });

        document.getElementById('followView').addEventListener('click', () => {
            currentCameraView = 'follow';
            controls.mouseButtons = { LEFT: 0, RIGHT: 2 };
            
            updateButtonStates();
        });

        document.getElementById('firstPersonView').addEventListener('click', () => {
            currentCameraView = 'firstPerson';
            controls.mouseButtons = { LEFT: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            
            updateButtonStates();
        });

        document.getElementById('birdsEyeView').addEventListener('click', () => {
            currentCameraView = 'birdsEye';

            controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, RIGHT: THREE.MOUSE.DOLLY_ROTATE };
            // Reset the panned flag to center on tractor when button is clicked
            birdViewPanned = false;
            updateButtonStates();
        });
        
        // Add mouse wheel zoom for birds-eye view
        renderer.domElement.addEventListener('wheel', function(event) {
            if (currentCameraView === 'birdsEye') {
                // Prevent the default scroll behavior
                event.preventDefault();
                
                // Determine zoom direction (in or out)
                const zoomSpeed = 2; // Adjust for faster/slower zoom
                // make zoom speed logarithmic to the birds eye height
                const delta = Math.sign(event.deltaY) * zoomSpeed * Math.log10(birdsEyeHeight);
                
                // Update birds-eye height
                birdsEyeHeight = Math.max(10, Math.min(2000, birdsEyeHeight + delta));
                
            }
        }, { passive: false });

        function updateButtonStates() {
            document.querySelectorAll('.camera-button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(`${currentCameraView}View`).classList.add('active');
            
            // Show or hide height control based on selected view
        
        }

        // Add these variables near the start of the script section, after scene initialization
        let frames = 0;
        let prevTime = performance.now();
        let fpsDisplay = document.getElementById('fpsCounter');

        // Add these new variables for the update counter
        let positionUpdates = 0;
        let updatePrevTime = performance.now();
        let updateDisplay = document.getElementById('updateCounter');

        // Function to update coordinates display
        function updateCoordinates() {
            if (!tractor) return;
            
            const coordsElement = document.getElementById('coordinates');
            coordsElement.innerHTML = `
                Lat: ${tractorPosition.lat.toFixed(4)}°<br>
                Lon: ${tractorPosition.lon.toFixed(4)}°<br>
                Heading: ${tractorPosition.heading.toFixed(1)}°<br>
                Speed: ${tractorPosition.speed.toFixed(1)} km/h<br>
                Time: ${tractorPosition.time.toLocaleString()}<br>
                <hr style="border-color: #666;">
                World X: ${tractorPosition.worldX.toFixed(1)}m<br>
                World Y: ${tractorPosition.worldY.toFixed(1)}m<br>
                World Heading: ${tractorPosition.worldHeading.toFixed(1)}° (N=0°)<br>
                <hr style="border-color: #666;">
                Target X: ${targetPoint.X.toFixed(1)}m<br>
                Target Y: ${targetPoint.Y.toFixed(1)}m<br>
                Target Steering: ${(targetSteeringAngle * 180 / Math.PI).toFixed(1)}°
            `;
        }

        // Modify the animate function to check for tractor existence
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS calculation
            frames++;
            const time = performance.now();
            
            if (time >= prevTime + 1000) {
                const fps = Math.round((frames * 1000) / (time - prevTime));
                fpsDisplay.textContent = `FPS: ${fps}`;
                frames = 0;
                prevTime = time;
            }
            
            if (tractor) { // Only update if tractor exists
                updateCameraPosition();
                controls.update();
                updateCoordinates();
            }
            
            // Update arrow scale based on camera position
            updateArrowScale();
            
            renderer.render(scene, camera);
        }

        // Add control panel handling
        const speedControl = document.getElementById('speedControl');
        const steeringControl = document.getElementById('steeringControl');
        const speedValue = document.getElementById('speedValue');
        const steeringValue = document.getElementById('steeringValue');
        const centerSteeringButton = document.getElementById('centerSteering');

        // Add auto-steering checkbox handling
        const autoSteeringCheckbox = document.getElementById('autoSteeringCheckbox');
        
        // Function to update steering based on target angle
        function updateAutoSteering() {
            if (!tractor || !autoSteeringCheckbox.checked) return;
            
            // Convert target steering angle from radians to degrees
            const targetSteeringDegrees = -(targetSteeringAngle * 180 / Math.PI);
            
            // Update steering control
            steeringControl.value = targetSteeringDegrees;
            
            // Update display value
            if (Math.abs(targetSteeringDegrees) < 0.1) {
                steeringValue.textContent = "Center";
            } else if (targetSteeringDegrees > 0) {
                steeringValue.textContent = `Left ${Math.abs(targetSteeringDegrees).toFixed(3)}°`;
            } else {
                steeringValue.textContent = `Right ${Math.abs(targetSteeringDegrees).toFixed(3)}°`;
            }

            tractor.setSteeringAngle(targetSteeringDegrees);
            
            // Send control update to server
            sendTractorControls();
        }

        // Disable manual steering control when auto-steering is enabled
        autoSteeringCheckbox.addEventListener('change', function() {
            steeringControl.disabled = this.checked;
            if (!this.checked) {
                // Reset to center when disabling auto-steering
                steeringControl.value = 0;
                steeringValue.textContent = "Center";
                sendTractorControls();
            }
        });

        // Update the existing steering control event listener
        steeringControl.addEventListener('input', () => {
            if (!tractor) return; // Don't update if tractor doesn't exist or auto-steering is enabled
            const value = -parseFloat(steeringControl.value);
            if (Math.abs(value) < 0.1) {
                steeringValue.textContent = "Center";
            } else if (value > 0) {
                steeringValue.textContent = `Left ${Math.abs(value).toFixed(1)}°`;
            } else {
                steeringValue.textContent = `Right ${Math.abs(value).toFixed(1)}°`;
            }
            tractor.setSteeringAngle(value);
            sendTractorControls();
        });

        // Update the center steering button handler
        centerSteeringButton.addEventListener('click', () => {
            if (!tractor || autoSteeringCheckbox.checked) return; // Don't update if auto-steering is enabled
            steeringControl.value = 0;
            steeringValue.textContent = "Center";
            tractor.setSteeringAngle(0);
            sendTractorControls();
        });

        speedControl.addEventListener('input', () => {
            const value = parseFloat(speedControl.value);
            speedValue.textContent = `${value.toFixed(1)} km/h`;
            sendTractorControls();
        });

        // Handle window resizing
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Add function to request path calculation
        function requestPathCalculation() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const config = {
                    type: 'calculatePath',
                    config: {
                        // check for implementWidth in settings.implement otherwise get from settings element
                        implementWidth: function() {
                            return settings.implement.width || parseFloat(document.getElementById('settings-implementWidth').value);
                        }
                    }
                };
                ws.send(JSON.stringify(config));
            }
        }

        // Add after the other control panel variables
        const lookAheadControl = document.getElementById('lookAheadControl');
        const planningDistControl = document.getElementById('planningDistControl');
        const deadzoneControl = document.getElementById('deadzoneControl');
        const lookAheadValue = document.getElementById('lookAheadValue');
        const planningDistValue = document.getElementById('planningDistValue');
        const deadzoneValue = document.getElementById('deadzoneValue');

        // Hide guidance tuning panel initially
        document.getElementById('guidanceTuningPanel').style.display = 'none';

        // Add new function to send guidance parameters
        function sendGuidanceParameters() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const params = {
                    type: 'guidanceParams',
                    lookAheadDistance: parseFloat(lookAheadControl.value),
                    planningDistance: parseFloat(planningDistControl.value),
                    deadzone: parseFloat(deadzoneControl.value) * Math.PI / 180.0  // Convert to radians
                };
                ws.send(JSON.stringify(params));
            }
        }

        // Add event listeners for guidance parameter controls
        lookAheadControl.addEventListener('input', () => {
            const value = parseFloat(lookAheadControl.value);
            lookAheadValue.textContent = `${value.toFixed(1)}`;
            sendGuidanceParameters();
        });

        planningDistControl.addEventListener('input', () => {
            const value = parseFloat(planningDistControl.value);
            planningDistValue.textContent = `${value.toFixed(1)}`;
            sendGuidanceParameters();
        });

        deadzoneControl.addEventListener('input', () => {
            const value = parseFloat(deadzoneControl.value);
            deadzoneValue.textContent = `${value.toFixed(1)}°`;
            sendGuidanceParameters();
        });

        // Add settings panel functionality
        document.addEventListener('DOMContentLoaded', function() {
            const settingsPanel = document.getElementById('settingsPanel');
            const openSettingsButton = document.getElementById('openSettings');
            const closeSettingsButton = document.getElementById('closeSettingsX');
            const cancelSettingsButton = document.getElementById('closeSettings');
            const saveSettingsButton = document.getElementById('saveSettings');
            const categoryButtons = document.querySelectorAll('.settings-category');
            const categoryContents = document.querySelectorAll('.settings-category-content');

            // Load settings from cookies on page load
            loadSettingsFromCookies();

            // Make a copy of current settings when opening panel
            let originalSettings = {};
            
            // Open settings panel
            openSettingsButton.addEventListener('click', function() {
                // Make a backup of current settings
                originalSettings = {
                    tractor: {
                        wheelbase: parseFloat(document.getElementById('settings-wheelbase').value),
                        hitchOffset: parseFloat(document.getElementById('settings-hitchOffset').value)
                    },
                    implement: {
                        length: parseFloat(document.getElementById('settings-implementLength').value),
                        width: parseFloat(document.getElementById('settings-implementWidth').value)
                    },
                    guidance: {
                        lookAhead: parseFloat(document.getElementById('lookAheadControl').value),
                        planningDistance: parseFloat(document.getElementById('planningDistControl').value),
                        deadzone: parseFloat(document.getElementById('deadzoneControl').value)
                    }
                };
                
                // Sync settings with current values
                syncSettings();
                
                // Show panel
                settingsPanel.style.display = 'flex';
            });

            // Close settings panel without saving (cancel)
            cancelSettingsButton.addEventListener('click', function() {
                // Restore original values
                if (originalSettings.tractor) {
                    document.getElementById('settings-wheelbase').value = originalSettings.tractor.wheelbase;
                    document.getElementById('settings-hitchOffset').value = originalSettings.tractor.hitchOffset;
                }
                
                if (originalSettings.implement) {
                    document.getElementById('settings-implementLength').value = originalSettings.implement.length;
                    document.getElementById('settings-implementWidth').value = originalSettings.implement.width;
                }
                
                if (originalSettings.guidance) {
                    document.getElementById('lookAheadControl').value = originalSettings.guidance.lookAhead;
                    lookAheadValue.textContent = originalSettings.guidance.lookAhead;
                    
                    document.getElementById('planningDistControl').value = originalSettings.guidance.planningDistance;
                    planningDistValue.textContent = originalSettings.guidance.planningDistance;
                    
                    document.getElementById('deadzoneControl').value = originalSettings.guidance.deadzone;
                    deadzoneValue.textContent = originalSettings.guidance.deadzone + '°';
                    
                    // Update guidance parameters
                    sendGuidanceParameters();
                }
                
                settingsPanel.style.display = 'none';
            });

            // Close settings panel (X button)
            closeSettingsButton.addEventListener('click', function() {
                // Same as cancel - don't save changes
                cancelSettingsButton.click();
            });
            
            // Save settings and close panel
            saveSettingsButton.addEventListener('click', function() {
                // Apply settings to form controls

                document.getElementById('lookAheadControl').value = document.getElementById('settings-lookAhead').value;
                lookAheadValue.textContent = document.getElementById('settings-lookAhead').value;
                document.getElementById('planningDistControl').value = document.getElementById('settings-planningDistance').value;
                planningDistValue.textContent = document.getElementById('settings-planningDistance').value;
                document.getElementById('deadzoneControl').value = document.getElementById('settings-deadzone').value;
                deadzoneValue.textContent = document.getElementById('settings-deadzone').value + '°';
                
                // Save to cookies
                saveSettingsToCookies();
                
                // Update guidance parameters
                sendGuidanceParameters();
                
                // Close panel
                settingsPanel.style.display = 'none';
                
                // Send updated configuration to server if needed
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const config = {
                        type: 'config',
                        tractor: {
                            wheelbase: parseFloat(document.getElementById('settings-wheelbase').value),
                            hitchOffset: parseFloat(document.getElementById('settings-hitchOffset').value)
                        },
                        implement: {
                            length: parseFloat(document.getElementById('settings-implementLength').value),
                            width: parseFloat(document.getElementById('settings-implementWidth').value)
                        }
                    };
                    ws.send(JSON.stringify(config));
                }
            });

            // Handle category selection
            categoryButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    categoryButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Hide all category contents
                    categoryContents.forEach(content => content.style.display = 'none');
                    // Show selected category content
                    const category = this.getAttribute('data-category');
                    document.getElementById(`${category}-settings`).style.display = 'block';
                });
            });

            // Sync settings with existing controls
            function syncSettings() {
               
                // GPS settings
                document.getElementById('settings-gpsLat').value = tractorPosition?.lat || -36.8013;
                document.getElementById('settings-gpsLon').value = tractorPosition?.lon || 142.3142;
                
                // Planner settings
                document.getElementById('settings-planningDistance').value = document.getElementById('planningDistControl').value;
                
                // Guidance settings
                document.getElementById('settings-lookAhead').value = document.getElementById('lookAheadControl').value;
                document.getElementById('settings-deadzone').value = document.getElementById('deadzoneControl').value;
            }
        });
    </script>
</body>
</html>
